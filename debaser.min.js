/*! angular-debaser - v0.0.0 - 2014-06-16
* https://github.com/decipherinc/angular-debaser
* Copyright (c) 2014 Decipher, Inc.; Licensed MIT */

!function(a,b){"use strict";var c,d=b.injector,e=b.isArray,f=b.extend;c=function g(c,h,i){var j,k,l,m;if(!c)throw new Error("debase requires a module name parameter");if(!h||e(h)&&!h.length)throw new Error("debase requires one or more target components");b.isString(h)&&(h=[h]),i=i||{},m=function(a,m,n,o,p){var q=n.getAdapter(i.adapter||o.adapter),r=n.contains;k=b.isDefined(i.auto)?i.auto:o.auto,l=f({},o.stubs,i.stubs),j=f({},o.ignores,n.makeSet(i.ignores||[])),b.module(c)._invokeQueue.forEach(function(a){var b,c=(a[1],a[2]),f=c[0];r(h,f)&&(b=e(c[1])?c[1].slice(0,-1):d().annotate(c[1]),b.forEach(function(a){var b;k&&!l[a]&&(l[a]=new p({$name:a,$type:"function"})),b=p.findStub(a,{stubs:l,adapter:q,ignores:j}),b&&b.provide()}))}),g._enabled=!1},m.$inject=["$provide","$injector","decipher.debaser.utils","decipher.debaser.options","decipher.debaser.stubProvider"],a.beforeEach(function(){b.mock.module(c,m),a.inject()})},c.options=function(a){var c=b.injector(["decipher.debaser"]).get("decipher.debaser.options");b.extend(c,a)},a.debase=c}(window,window.angular),function(a,b,c){"use strict";var d=["function","object","array","regexp","date"],e=["factory","service","provider"];a.module("decipher.debaser",["ngMock"]).constant("decipher.debaser.constants",{STUB_TYPES:d,COMPONENTS:e}).constant("decipher.debaser.options",{adapter:"$"+(c?"sinon":"vanilla")+"Debaser",ignores:{},stubs:{},auto:!1})}(window.angular,window.beforeEach,window.sinon),function(a){"use strict";a.module("decipher.debaser").provider("decipher.debaser.adapters.sinon",function(){this.$get=function(){throw new Error("not implemented")}})}(window.angular),function(a){"use strict";a.module("decipher.debaser").provider("decipher.debaser.adapters.vanilla",function(){var b=function(a){var b=Number(a);return b|0===a};return{object:function(a){return new Object(a)},"function":function(c){var d=c.prototype,e=c.returns,f=c.returnsArg,g=c.callsArg,h=c.callsArgParams,i=c.callsArgContext||null,j=c.context||null,k="";if(g){if(b(g)||isNaN(g))throw new Error("callsArg must be an integer");if(h&&!a.isArray(h))throw new Error("callsArgWith must be an array of parameters");k+="arguments[target].apply(callCtx, params);"}if(f){if(b(f)||isNaN(f))throw new Error("returnsArg must be an integer");k+="return arguments[identity];"}else e&&(k+="return retval;");return function(a,b,c,d,e,f,g,h){var i=new Function(a).bind(b);return h&&(i.prototype=Object.create(h)),i}(k,j,g,i,h||[],f,e,d)},array:function(){return 0===arguments.length?[]:Array.prototype.slice.apply(arguments)},regexp:function(){return new RegExp},date:function(){return new Date},$get:function(){throw new Error("not implemented")}}})}(window.angular),function(a){"use strict";a.module("decipher.debaser").provider("decipher.debaser.stub",["$provide","decipher.debaser.constants",function(b,c){var d=function(b,c){a.extend(this,b),this.$opts=c||{}};return d.prototype.initProp=function(b,c){a.isUndefined(this[b])&&(this[b]=c)},d.prototype.provide=function(){var a=this.$opts.provider?"constant":"value";b[a](this.$name,this.$proxy)},d.findStub=function e(b,f){var g,h,i,j;if(f=f||{},g=f.stubs,h=f.adapter,i=f.ignores||[],!b)throw new Error("name is required");if(!Object.keys(g).length)throw new Error("define stubs!");if(!h)throw new Error("where the hell is the adapter?");if(a.isDefined(e.cache[b]))return e.cache[b];if(i[b])return e.cache[b]=null;if(j=g[b]){if(a.isString(j)){if(j=j.toLowerCase(),!h[j])throw new Error('Unknown stub type "'+j+'".  Valid types are: '+c.STUB_TYPES.join(", "));j=new d({$type:j,$name:b,$proxy:h[j]()})}else j.constructor===d?j.$type&&j.initProp("$proxy",h[j.$type](j.$opts)):j=new d({$name:b,$proxy:j});return e.cache[b]=j}},d.findStub.cache={},d.$get=function(){throw new Error("not implemented")},d}])}(window.angular),function(a){"use strict";var b,c,d;b=function(a,b){return a.indexOf(b)>-1},c=function(b){var c={};return b.forEach(function(b){a.isString(b)&&(c[b]=!0)}),c},d=function e(b){if(e.cache[b])return e.cache[b];if(!a.isString(b))return e.cache[b]=b;try{return e.cache[b]=a.injector(["decipher.debaser"]).get(b)}catch(c){throw new Error('debaser: unknown adapter "'+b+'"')}},d.cache={},a.module("decipher.debaser").constant("decipher.debaser.utils",{getAdapter:d,makeSet:c,contains:b})}(window.angular),function(a,b){"use strict";a.module("decipher.debaser").config(["$injector","decipher.debaser.utils","decipher.debaser.constants","decipher.debaser.stubProvider","decipher.debaser.options",function(c,d,e,f,g){b.stub=function(b,c){var h=e.STUB_TYPES,i=d.contains;if(c=a.extend({},g,c),!b)throw new Error("Parameter required");if(a.isString(b)){if(b=b.toLowerCase(),!i(h,b))throw new Error('Unknown stub type "'+b+'".  Valid types are: '+h.join(", ")+". To use a custom value, do not use this function.");return new f({$type:b},c)}return new f({$proxy:b.bind(c.context||null)},c)},b._enabled=!0}])}(window.angular,window.debase),function(a,b){"use strict";b(a.mock.module("decipher.debaser"))}(window.angular,window.beforeEach);
//# sourceMappingURL=debaser.min.js.map